<?xml version="1.0" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"
[
]>

<article id="index">
  <articleinfo>
    <title>D-BUS Tutorial</title>
    <releaseinfo>Version 0.3</releaseinfo>
    <date>18 January 2005</date>
    <authorgroup>
      <author>
	<firstname>Havoc</firstname>
	<surname>Pennington</surname>
	<affiliation>
	  <orgname>Red Hat, Inc.</orgname>
	  <address>
	    <email>hp@pobox.com</email>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>David</firstname>
	<surname>Wheeler</surname>
      </author>
    </authorgroup>
  </articleinfo>

  <sect1 id="whatis">
    <title>What is D-BUS?</title>
    <para>
      D-BUS is a system for <firstterm>interprocess communication</firstterm>
      (IPC). Architecturally, it has several layers:

      <itemizedlist>
        <listitem>
          <para>
            A library, <firstterm>libdbus</firstterm>, that allows two
            applications to connect to each other and exchange messages.
          </para>
        </listitem>
        <listitem>
          <para>
            A <firstterm>message bus daemon</firstterm> executable, built on
            libdbus, that multiple applications can connect to. The daemon can
            route messages from one application to zero or more other
            applications.
          </para>
        </listitem>
        <listitem>
          <para>
            <firstterm>Wrapper libraries</firstterm> based on particular
            application frameworks.  For example, libdbus-glib and
            libdbus-qt. There are also bindings to languages such as
            Python. These wrapper libraries are the API most people should use,
            as they simplify the details of D-BUS programming. libdbus is 
            intended to be a low-level backend for the higher level bindings.
            Much of the libdbus API is only useful for binding implementation.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      If you just want to use D-BUS and don't care how it works, jump directly
      to <xref linkend="concepts"/>.
      Otherwise, read on.
    </para>

    <para>
      libdbus only supports one-to-one connections, just like a raw network
      socket. However, rather than sending byte streams over the connection, you
      send <firstterm>messages</firstterm>. Messages have a header identifying
      the kind of message, and a body containing a data payload. libdbus also
      abstracts the exact transport used (sockets vs. whatever else), and
      handles details such as authentication.
    </para>

    <para>
      The message bus daemon forms the hub of a wheel. Each spoke of the wheel
      is a one-to-one connection to an application using libdbus.  An
      application sends a message to the bus daemon over its spoke, and the bus
      daemon forwards the message to other connected applications as
      appropriate. Think of the daemon as a router.
    </para>

    <para>
      The bus daemon has multiple instances on a typical computer.  The
      first instance is a machine-global singleton, that is, a system daemon
      similar to sendmail or Apache. This instance has heavy security
      restrictions on what messages it will accept, and is used for systemwide
      communication. The other instances are created one per user login session.
      These instances allow applications in the user's session to communicate 
      with one another.
    </para>

    <para>
      The systemwide and per-user daemons are separate.  Normal within-session
      IPC does not involve the systemwide message bus process and vice versa.
    </para>

    <sect2 id="uses">
      <title>D-BUS applications</title>
      <para>
        There are many, many technologies in the world that have "Inter-process
        communication" or "networking" in their stated purpose: <ulink
        url="http://www.omg.org">CORBA</ulink>, <ulink
        url="http://www.opengroup.org/dce/">DCE</ulink>, <ulink
        url="http://www.microsoft.com/com/">DCOM</ulink>, <ulink
        url="http://developer.kde.org/documentation/library/kdeqt/dcop.html">DCOP</ulink>, <ulink
        url="http://www.xmlrpc.com">XML-RPC</ulink>, <ulink
        url="http://www.w3.org/TR/SOAP/">SOAP</ulink>, <ulink
        url="http://www.mbus.org/">MBUS</ulink>, <ulink
        url="http://www.zeroc.com/ice.html">Internet Communications Engine (ICE)</ulink>,
        and probably hundreds more.
        Each of these is tailored for particular kinds of application.
        D-BUS is designed for two specific cases:
        <itemizedlist>
          <listitem>
            <para>
              Communication between desktop applications in the same desktop
              session; to allow integration of the desktop session as a whole,
              and address issues of process lifecycle (when do desktop components 
              start and stop running).
            </para>
          </listitem>
          <listitem>
            <para>
              Communication between the desktop session and the operating system, 
              where the operating system would typically include the kernel 
              and any system daemons or processes.
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        For the within-desktop-session use case, the GNOME and KDE desktops 
        have significant previous experience with different IPC solutions
        such as CORBA and DCOP. D-BUS is built on that experience and 
        carefully tailored to meet the needs of these desktop projects 
        in particular. D-BUS may or may not be appropriate for other 
        applications; the FAQ has some comparisons to other IPC systems.
      </para>
      <para>
        The problem solved by the systemwide or communication-with-the-OS case 
        is explained well by the following text from the Linux Hotplug project:
        <blockquote>
          <para>
           A gap in current Linux support is that policies with any sort of
           dynamic "interact with user" component aren't currently
           supported. For example, that's often needed the first time a network
           adapter or printer is connected, and to determine appropriate places
           to mount disk drives. It would seem that such actions could be
           supported for any case where a responsible human can be identified:
           single user workstations, or any system which is remotely
           administered.
          </para>

          <para>
            This is a classic "remote sysadmin" problem, where in this case
            hotplugging needs to deliver an event from one security domain
            (operating system kernel, in this case) to another (desktop for
            logged-in user, or remote sysadmin). Any effective response must go
            the other way: the remote domain taking some action that lets the
            kernel expose the desired device capabilities. (The action can often
            be taken asynchronously, for example letting new hardware be idle
            until a meeting finishes.) At this writing, Linux doesn't have
            widely adopted solutions to such problems. However, the new D-Bus
            work may begin to solve that problem.
          </para>
        </blockquote>
      </para>
      <para>
        D-BUS may happen to be useful for purposes other than the one it was
        designed for. Its general properties that distinguish it from 
        other forms of IPC are:
        <itemizedlist>
          <listitem>
            <para>
              Binary protocol designed to be used asynchronously 
              (similar in spirit to the X Window System protocol).
            </para>
          </listitem>
          <listitem>
            <para>
              Stateful, reliable connections held open over time.
            </para>
          </listitem>
          <listitem>
            <para>
              The message bus is a daemon, not a "swarm" or 
              distributed architecture.
            </para>
          </listitem>
          <listitem>
            <para>
              Many implementation and deployment issues are specified rather
              than left ambiguous.
            </para>
          </listitem>
          <listitem>
            <para>
              Semantics are similar to the existing DCOP system, allowing 
              KDE to adopt it more easily.
            </para>
          </listitem>
          <listitem>
            <para>
              Security features to support the systemwide mode of the 
              message bus.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect2>
  </sect1>
  <sect1 id="concepts">
    <title>Concepts</title>
    <para>
      Some basic concepts apply no matter what application framework you're
      using to write a D-BUS application. The exact code you write will be
      different for GLib vs. Qt vs. Python applications, however.
    </para>
    
    <para>
      Here is a diagram (<ulink url="diagram.png">png</ulink> <ulink
      url="diagram.svg">svg</ulink>) that may help you visualize the concepts
      that follow.
    </para>

    <sect2 id="objects">
      <title>Objects and Object Paths</title>
      <para>
        Each application using D-BUS contains <firstterm>objects</firstterm>,
        which generally map to GObject, QObject, C++ objects, or Python objects
        (but need not).  An object is an <emphasis>instance</emphasis> rather
        than a type.  When messages are received over a D-BUS connection, they
        are sent to a specific object, not to the application as a whole.
      </para>
      <para>
        To allow messages to specify their destination object, there has to be a
        way to refer to an object. In your favorite programming language, this
        is normally called a <firstterm>pointer</firstterm> or
        <firstterm>reference</firstterm>. However, these references are
        implemented as memory addresses relative to the address space of your
        application, and thus can't be passed from one application to another.
      </para>
      <para>
        To solve this, D-BUS introduces a name for each object. The name 
        looks like a filesystem path, for example an object could be 
        named <literal>/org/kde/kspread/sheets/3/cells/4/5</literal>. 
        Human-readable paths are nice, but you are free to create an 
        object named <literal>/com/mycompany/c5yo817y0c1y1c5b</literal> 
        if it makes sense for your application.
      </para>
      <para>
        Namespacing object paths is smart, by starting them with the components
        of a domain name you own (e.g. <literal>/org/kde</literal>). This 
        keeps different code modules in the same process from stepping 
        on one another's toes.
      </para>
    </sect2>    

    <sect2 id="interfaces">
      <title>Interfaces</title>
      <para>
        Each object supports one or more <firstterm>interfaces</firstterm>.
        Think of an interface as a named group of methods and signals, 
        just as it is in GLib or Qt or Java. Interfaces define the 
        <emphasis>type</emphasis> of an object instance.
      </para>
    </sect2>
      
    <sect2 id="messages">
      <title>Message Types</title>
      <para>
        Messages are not all the same; in particular, D-BUS has 
        4 built-in message types:
        <itemizedlist>
          <listitem>
            <para>
              Method call messages ask to invoke a method 
              on an object.
            </para>
          </listitem>
          <listitem>
            <para>
              Method return messages return the results 
              of invoking a method.
            </para>
          </listitem>
          <listitem>
            <para>
              Error messages return an exception caused by 
              invoking a method.
            </para>
          </listitem>
          <listitem>
            <para>
              Signal messages are notifications that a given signal 
              has been emitted (that an event has occurred). 
              You could also think of these as "event" messages.
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        A method call maps very simply to messages, then: you send a method call
        message, and receive either a method return message or an error message
        in reply.
      </para>
    </sect2>

    <sect2 id="bus-names">
      <title>Bus Names</title>
      
      <para>
        Object paths, interfaces, and messages exist on the level of 
        libdbus and the D-BUS protocol; they are used even in the 
        1-to-1 case with no message bus involved.
      </para>

      <para>
        Bus names, on the other hand, are a property of the message bus daemon.
        The bus maintains a mapping from names to message bus connections.
        These names are used to specify the origin and destination
        of messages passing through the message bus. When a name is mapped 
        to a particular application's connection, that application is said to 
        <firstterm>own</firstterm> that name.
      </para>

      <para>
        On connecting to the bus daemon, each application immediately owns a
        special name called the <firstterm>unique connection name</firstterm>.
        A unique name begins with a ':' (colon) character; no other names are
        allowed to begin with that character. Unique names are special because
        they are created dynamically, and are never re-used during the lifetime
        of the same bus daemon. You know that a given unique name will have the
        same owner at all times.  An example of a unique name might be
        <literal>:34-907</literal>. The numbers after the colon have 
        no meaning other than their uniqueness.
      </para>

      <para>
        Applications may ask to own additional <firstterm>well-known
        names</firstterm>. For example, you could write a specification to
        define a name called <literal>com.mycompany.TextEditor</literal>.
        Your definition could specify that to own this name, an application
        should have an object at the path
        <literal>/com/mycompany/TextFileManager</literal> supporting the
        interface <literal>org.freedesktop.FileHandler</literal>.        
      </para>
      
      <para>
        Applications could then send messages to this bus name, 
        object, and interface to execute method calls.
      </para>

      <para>
        You could think of the unique names as IP addresses, and the
        well-known names as domain names. So
        <literal>com.mycompany.TextEditor</literal> might map to something like
        <literal>:34-907</literal> just as <literal>mycompany.com</literal> maps
        to something like <literal>192.168.0.5</literal>.
      </para>
      
      <para>
        Names have a second important use, other than routing messages.  They
        are used to track lifecycle. When an application exits (or crashes), its
        connection to the message bus will be closed by the operating system
        kernel. The message bus then sends out notification messages telling
        remaining applications that the application's names have lost their
        owner. By tracking these notifications, your application can reliably
        monitor the lifetime of other applications.
      </para>

    </sect2>

    <sect2 id="addresses">
      <title>Addresses</title>

      <para>
        Applications using D-BUS are either servers or clients.  A server
        listens for incoming connections; a client connects to a server. Once
        the connection is established, it is a symmetric flow of messages; the
        client-server distinction only matters when setting up the 
        connection.
      </para>

      <para>
        A D-BUS <firstterm>address</firstterm> specifies where a server will
        listen, and where a client will connect.  For example, the address
        <literal>unix:path=/tmp/abcdef</literal> specifies that the server will
        listen on a UNIX domain socket at the path
        <literal>/tmp/abcdef</literal> and the client will connect to that
        socket. An address can also specify TCP/IP sockets, or any other
        transport defined in future iterations of the D-BUS specification.
      </para>

      <para>
        When using D-BUS with a message bus, the bus daemon is a server 
        and all other applications are clients of the bus daemon.
        libdbus automatically discovers the address of the per-session bus 
        daemon by reading an environment variable. It discovers the 
        systemwide bus daemon by checking a well-known UNIX domain socket path
        (though you can override this address with an environment variable).
      </para>

      <para>
        If you're using D-BUS without a bus daemon, it's up to you to 
        define which application will be the server and which will be 
        the client, and specify a mechanism for them to agree on 
        the server's address.
      </para>

    </sect2>

    <sect2 id="bigpicture">
      <title>Big Conceptual Picture</title>

      <para>
        Pulling all these concepts together, to specify a particular 
        method call on a particular object instance, a number of 
        nested components have to be named:
        <programlisting>
          Address -&gt; [Bus Name] -&gt; Path -&gt; Interface -&gt; Method
        </programlisting>
        The bus name is in brackets to indicate that it's optional -- you only
        provide a name to route the method call to the right application
        when using the bus daemon. If you have a direct connection to another
        application, bus names aren't used; there's no bus daemon.
      </para>

      <para>
        The interface is also optional, primarily for historical 
        reasons; DCOP does not require specifying the interface, 
        instead simply forbidding duplicate method names 
        on the same object instance. D-BUS will thus let you 
        omit the interface, but if your method name is ambiguous 
        it is undefined which method will be invoked.
      </para>
      
    </sect2>

  </sect1>

  <sect1 id="glib-client">
    <title>GLib API: Using Remote Objects</title>

    <para>
      The GLib binding is defined in the header file
      &lt;dbus/dbus-glib.h&gt;.
    </para>

    <sect2 id="glib-typemappings">
      <title>D-BUS - GLib type mappings</title>
      <para>
	The heart of the GLib bindings for D-BUS is the mapping it
	provides between D-BUS "type signatures" and GLib types
	(<literal>GType</literal>). The D-BUS type system is composed of
	a number of "basic" types, along with several "container" types.
      </para>
      <sect3 id="glib-basic-typemappings">
	<title>Basic type mappings</title>
	<para>
	  Below is a list of the basic types, along with their associated
	  mapping to a <literal>GType</literal>.
	  <informaltable>
	    <tgroup cols="4">
	      <thead>
		<row>
		  <entry>D-BUS basic type</entry>
		  <entry>GType</entry>
		  <entry>Free function</entry>
		  <entry>Notes</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><literal>BYTE</literal></entry>
		  <entry><literal>G_TYPE_UCHAR</literal></entry>
		  <entry></entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>BOOLEAN</literal></entry>
		  <entry><literal>G_TYPE_BOOLEAN</literal></entry>
		  <entry></entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>INT16</literal></entry>
		  <entry><literal>G_TYPE_INT</literal></entry>
		  <entry></entry>
		  <entry>Will be changed to a G_TYPE_INT16 once GLib has it</entry>
		  </row><row>
		  <entry><literal>UINT16</literal></entry>
		  <entry><literal>G_TYPE_UINT</literal></entry>
		  <entry></entry>
		  <entry>Will be changed to a G_TYPE_UINT16 once GLib has it</entry>
		  </row><row>
		  <entry><literal>INT32</literal></entry>
		  <entry><literal>G_TYPE_INT</literal></entry>
		  <entry></entry>
		  <entry>Will be changed to a G_TYPE_INT32 once GLib has it</entry>
		  </row><row>
		  <entry><literal>UINT32</literal></entry>
		  <entry><literal>G_TYPE_UINT</literal></entry>
		  <entry></entry>
		  <entry>Will be changed to a G_TYPE_UINT32 once GLib has it</entry>
		  </row><row>
		  <entry><literal>INT64</literal></entry>
		  <entry><literal>G_TYPE_GINT64</literal></entry>
		  <entry></entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>UINT64</literal></entry>
		  <entry><literal>G_TYPE_GUINT64</literal></entry>
		  <entry></entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>DOUBLE</literal></entry>
		  <entry><literal>G_TYPE_DOUBLE</literal></entry>
		  <entry></entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>STRING</literal></entry>
		  <entry><literal>G_TYPE_STRING</literal></entry>
		  <entry>g_free</entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>OBJECT_PATH</literal></entry>
		  <entry><literal>DBUS_TYPE_G_PROXY</literal></entry>
		  <entry>g_object_unref</entry>
		  <entry>The returned proxy does not have an interface set; use <literal>dbus_g_proxy_set_interface</literal> to invoke methods</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  As you can see, the basic mapping is fairly straightforward.
	</para>
      </sect3>
      <sect3 id="glib-container-typemappings">
	<title>Container type mappings</title>
	<para>
	  The D-BUS type system also has a number of "container"
	  types, such as <literal>DBUS_TYPE_ARRAY</literal> and
	  <literal>DBUS_TYPE_STRUCT</literal>.  The D-BUS type system
	  is fully recursive, so one can for example have an array of
	  array of strings (i.e. type signature
	  <literal>aas</literal>).
	</para>
	<para>
	  However, not all of these types are in common use; for
	  example, at the time of this writing the author knows of no
	  one using <literal>DBUS_TYPE_STRUCT</literal>, or a
	  <literal>DBUS_TYPE_ARRAY</literal> containing any non-basic
	  type.  The approach the GLib bindings take is pragmatic; try
	  to map the most common types in the most obvious way, and
	  let using less common and more complex types be less
	  "natural".
	</para>
	<para>
	  First, D-BUS type signatures which have an "obvious"
	  corresponding builtin GLib type are mapped using that type:
	  <informaltable>
	    <tgroup cols="6">
	      <thead>
		<row>
		  <entry>D-BUS type signature</entry>
		  <entry>Description</entry>
		  <entry>GType</entry>
		  <entry>C typedef</entry>
		  <entry>Free function</entry>
		  <entry>Notes</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><literal>as</literal></entry>
		  <entry>Array of strings</entry>
		  <entry><literal>G_TYPE_STRV</literal></entry>
		  <entry><literal>char **</literal></entry>
		  <entry>g_strfreev</entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>v</literal></entry>
		  <entry>Generic value container</entry>
		  <entry><literal>G_TYPE_VALUE</literal></entry>
		  <entry><literal>GValue *</literal></entry>
		  <entry>g_value_unset</entry>
		  <entry>The calling conventions for values expect that method callers have allocated return values; see below.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	</para>
	<para>
	  The next most common recursive type signatures are arrays of
	  basic values.  The most obvious mapping for arrays of basic
	  types is a <literal>GArray</literal>.  Now, GLib does not
	  provide a builtin <literal>GType</literal> for
	  <literal>GArray</literal>.  However, we actually need more than
	  that - we need a "parameterized" type which includes the
	  contained type.  Why we need this we will see below.
	</para>
	<para>
	  The approach taken is to create these types in the D-BUS GLib
	  bindings; however, there is nothing D-BUS specific about them.
	  In the future, we hope to include such "fundamental" types in GLib
	  itself.
	  <informaltable>
	    <tgroup cols="6">
	      <thead>
		<row>
		  <entry>D-BUS type signature</entry>
		  <entry>Description</entry>
		  <entry>GType</entry>
		  <entry>C typedef</entry>
		  <entry>Free function</entry>
		  <entry>Notes</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><literal>ay</literal></entry>
		  <entry>Array of bytes</entry>
		  <entry><literal>DBUS_TYPE_G_BYTE_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry><literal>au</literal></entry>
		  <entry>Array of uint</entry>
		  <entry><literal>DBUS_TYPE_G_UINT_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry><literal>ai</literal></entry>
		  <entry>Array of int</entry>
		  <entry><literal>DBUS_TYPE_G_INT_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry><literal>ax</literal></entry>
		  <entry>Array of int64</entry>
		  <entry><literal>DBUS_TYPE_G_INT64_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry><literal>at</literal></entry>
		  <entry>Array of uint64</entry>
		  <entry><literal>DBUS_TYPE_G_UINT64_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry><literal>ad</literal></entry>
		  <entry>Array of double</entry>
		  <entry><literal>DBUS_TYPE_G_DOUBLE_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry><literal>ab</literal></entry>
		  <entry>Array of boolean</entry>
		  <entry><literal>DBUS_TYPE_G_BOOLEAN_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	</para>
	<para>
	  D-BUS also includes a special type DBUS_TYPE_DICT_ENTRY which
	  is only valid in arrays.  It's intended to be mapped to a "dictionary"
	  type by bindings.  The obvious GLib mapping here is GHashTable.  Again,
	  however, there is no builtin <literal>GType</literal> for a GHashTable.
	  Moreover, just like for arrays, we need a parameterized type so that
	  the bindings can communiate which types are contained in the hash table.
	</para>
	<para>
	  At present, only strings are supported.  Work is in progress to
	  include more types.
	  <informaltable>
	    <tgroup cols="6">
	      <thead>
		<row>
		  <entry>D-BUS type signature</entry>
		  <entry>Description</entry>
		  <entry>GType</entry>
		  <entry>C typedef</entry>
		  <entry>Free function</entry>
		  <entry>Notes</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><literal>a{ss}</literal></entry>
		  <entry>Dictionary mapping strings to strings</entry>
		  <entry><literal>DBUS_TYPE_G_STRING_STRING_HASHTABLE</literal></entry>
		  <entry><literal>GHashTable *</literal></entry>
		  <entry>g_hash_table_destroy</entry>
		  <entry></entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	</para>
      </sect3>
      <sect3 id="glib-generic-typemappings">
	<title>Arbitrarily recursive type mappings</title>
	<para>
	  Finally, it is possible users will want to write or invoke D-BUS
	  methods which have arbitrarily complex type signatures not
	  directly supported by these bindings.  For this case, we have a
	  <literal>DBusGValue</literal> which acts as a kind of special
	  variant value which may be iterated over manually.  The
	  <literal>GType</literal> associated is
	  <literal>DBUS_TYPE_G_VALUE</literal>.
	</para>
	<para>
	  TODO insert usage of <literal>DBUS_TYPE_G_VALUE</literal> here.
	</para>
      </sect3>
    </sect2>
    <sect2 id="sample-program-1">
      <title>A sample program</title>
      <para>Here is a D-BUS program using the GLib bindings.
<programlisting>      
int
main (int argc, char **argv)
{
  DBusGConnection *connection;
  GError *error;
  DBusGProxy *proxy;
  char **name_list;
  char **name_list_ptr;
  
  g_type_init ();

  error = NULL;
  connection = dbus_g_bus_get (DBUS_BUS_SESSION,
                               &amp;error);
  if (connection == NULL)
    {
      g_printerr ("Failed to open connection to bus: %s\n",
                  error-&gt;message);
      g_error_free (error);
      exit (1);
    }

  /* Create a proxy object for the "bus driver" (name "org.freedesktop.DBus") */
  
  proxy = dbus_g_proxy_new_for_name (connection,
                                     DBUS_SERVICE_DBUS,
                                     DBUS_PATH_DBUS,
                                     DBUS_INTERFACE_DBUS);

  /* Call ListNames method, wait for reply */
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "ListNames", &amp;error, G_TYPE_INVALID,
                          G_TYPE_STRV, &amp;name_list, G_TYPE_INVALID))
    {
      /* Just do demonstrate remote exceptions versus regular GError */
      if (error->domain == DBUS_GERROR &amp;&amp; error->code == DBUS_GERROR_REMOTE_EXCEPTION)
        g_printerr ("Caught remote method exception %s: %s",
	            dbus_g_error_get_name (error),
	            error-&gt;message);
      else
        g_printerr ("Error: %s\n", error-&gt;message);
      g_error_free (error);
      exit (1);
    }

  /* Print the results */
 
  g_print ("Names on the message bus:\n");
  
  for (name_list_ptr = name_list; *name_list_ptr; name_list_ptr++)
    {
      g_print ("  %s\n", *name_list_ptr);
    }
  g_strfreev (name_list);

  g_object_unref (proxy);

  return 0;
}
</programlisting>
    </para>
    </sect2>
    <sect2 id="glib-program-setup">
      <title>Program initalization</title>
      <para>
	A connection to the bus is acquired using
	<literal>dbus_g_bus_get</literal>.  Next, a proxy
	is created for the object "/org/freedesktop/DBus" with
	interface <literal>org.freedesktop.DBus</literal>
	on the service <literal>org.freedesktop.DBus</literal>.
	This is a proxy for the message bus itself.
      </para>
    </sect2>
    <sect2 id="glib-method-invocation">
      <title>Understanding method invocation</title>
      <para>
	You have a number of choices for method invocation.  First, as
	used above, <literal>dbus_g_proxy_call</literal> sends a
	method call to the remote object, and blocks until reply is
	recieved.  The outgoing arguments are specified in the varargs
	array, terminated with <literal>G_TYPE_INVALID</literal>.
	Next, pointers to return values are specified, followed again
	by <literal>G_TYPE_INVALID</literal>.
      </para>
      <para>
	To invoke a method asynchronously, use
	<literal>dbus_g_proxy_begin_call</literal>.  This returns a
	<literal>DBusGPendingCall</literal> object; you may then set a
	notification function using
	<literal>dbus_g_pending_call_set_notify</literal>.
      </para>
    </sect2>
    <sect2 id="glib-signal-connection">
      <title>Connecting to object signals</title>
      <para>
	You may connect to signals using
	<literal>dbus_g_proxy_add_signal</literal> and
	<literal>dbus_g_proxy_connect_signal</literal>.  You must
	invoke <literal>dbus_g_proxy_add_signal</literal> to specify
	the signature of your signal handlers; you may then invoke
	<literal>dbus_g_proxy_connect_signal</literal> multiple times.
      </para>
      <para>
	Note that it will often be the case that there is no builtin
	marshaller for the type signature of a remote signal.  In that
	case, you must generate a marshaller yourself by using
	<application>glib-genmarshal</application>, and then register
	it using <literal>dbus_g_object_register_marshaller</literal>.
      </para>
    </sect2>
    <sect2 id="glib-error-handling">
      <title>Error handling and remote exceptions</title>
      <para>
	All of the GLib binding methods such as
	<literal>dbus_g_proxy_end_call</literal> return a
	<literal>GError</literal>.  This <literal>GError</literal> can
	represent two different things:
      <itemizedlist>
	<listitem>
	  <para>
	    An internal D-BUS error, such as an out-of-memory
	    condition, an I/O error, or a network timeout.  Errors
	    generated by the D-BUS library itself have the domain
	    <literal>DBUS_GERROR</literal>, and a corresponding code
	    such as <literal>DBUS_GERROR_NO_MEMORY</literal>.  It will
	    not be typical for applications to handle these errors
	    specifically.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    A remote D-BUS exception, thrown by the peer, bus, or
	    service.  D-BUS remote exceptions have both a textual
	    "name" and a "message".  The GLib bindings store this
	    information in the <literal>GError</literal>, but some
	    special rules apply.
	  </para>
	  <para>
	    The set error will have the domain
	    <literal>DBUS_GERROR</literal> as above, and will also
	    have the code
	    <literal>DBUS_GERROR_REMOTE_EXCEPTION</literal>.  In order
	    to access the remote exception name, you must use a
	    special accessor, such as
	    <literal>dbus_g_error_has_name</literal> or
	    <literal>dbus_g_error_get_name</literal>.  The remote
	    exception detailed message is accessible via the regular
	    GError <literal>message</literal> member.
	  </para>
	</listitem>
      </itemizedlist>
      </para>
    </sect2>
    <sect2 id="glib-more-examples">
      <title>More examples of method invocation</title>
      <sect3 id="glib-sending-stuff">
	<title>Sending an integer and string, receiving an array of bytes</title>
	<para>
<programlisting>
  GArray *arr;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "Foobar", &amp;error,
                          G_TYPE_INT, 42, G_TYPE_STRING, "hello",
			  G_TYPE_INVALID,
			  DBUS_TYPE_G_UCHAR_ARRAY, &amp;arr, G_TYPE_INVALID))
    {
      /* Handle error */
    }
   g_assert (arr != NULL);
   printf ("got back %u values", arr->len);
</programlisting>
	</para>
      </sect3>
      <sect3 id="glib-sending-hash">
	<title>Sending a GHashTable</title>
	<para>
<programlisting>
  GHashTable *hash = g_hash_table_new (g_str_hash, g_str_equal);
  guint32 ret;
  
  g_hash_table_insert (hash, "foo", "bar");
  g_hash_table_insert (hash, "baz", "whee");

  error = NULL;
  if (!dbus_g_proxy_call (proxy, "HashSize", &amp;error,
                          DBUS_TYPE_G_STRING_STRING_HASH, hash, G_TYPE_INVALID,
			  G_TYPE_UINT, &amp;ret, G_TYPE_INVALID))
    {
      /* Handle error */
    }
  g_assert (ret == 2);
  g_hash_table_destroy (hash);
</programlisting>
	</para>
      </sect3>
      <sect3 id="glib-receiving-bool-int">
	<title>Receiving a boolean and a string</title>
	<para>
<programlisting>
  gboolean boolret;
  char *strret;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "GetStuff", &amp;error,
			  G_TYPE_INVALID,
                          G_TYPE_BOOLEAN, &amp;boolret,
                          G_TYPE_STRING, &amp;strret,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
  printf ("%s %s", boolret ? "TRUE" : "FALSE", strret);
  g_free (strret);
</programlisting>
	</para>
      </sect3>
      <sect3 id="glib-sending-str-arrays">
	<title>Sending two arrays of strings</title>
	<para>
<programlisting>
  /* NULL terminate */
  char *strs_static[] = {"foo", "bar", "baz", NULL};
  /* Take pointer to array; cannot pass array directly */
  char **strs_static_p = strs_static;
  char **strs_dynamic;

  strs_dynamic = g_new (char *, 4);
  strs_dynamic[0] = g_strdup ("hello");
  strs_dynamic[1] = g_strdup ("world");
  strs_dynamic[2] = g_strdup ("!");
  /* NULL terminate */
  strs_dynamic[3] = NULL;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "TwoStrArrays", &amp;error,
                          G_TYPE_STRV, strs_static_p,
                          G_TYPE_STRV, strs_dynamic,
			  G_TYPE_INVALID,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
   g_strfreev (strs_dynamic);
</programlisting>
	</para>
      </sect3>
      <sect3 id="glib-getting-str-array">
	<title>Sending a boolean, receiving an array of strings</title>
	<para>
<programlisting>
  char **strs;
  char **strs_p;
  gboolean blah;

  error = NULL;
  blah = TRUE;
  if (!dbus_g_proxy_call (proxy, "GetStrs", &amp;error,
                          G_TYPE_BOOLEAN, blah,
			  G_TYPE_INVALID,
                          G_TYPE_STRV, &amp;strs,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
   for (strs_p = strs; *strs_p; strs_p++)
     printf ("got string: \"%s\"", *strs_p);
   g_strfreev (strs);
</programlisting>
	</para>
      </sect3>
      <sect3 id="glib-sending-variant">
	<title>Sending a variant</title>
	<para>
<programlisting>
  GValue val = {0, };

  g_value_init (&amp;val, G_TYPE_STRING);
  g_value_set_string (&amp;val, "hello world");
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "SendVariant", &amp;error,
                          G_TYPE_VALUE, &amp;val, G_TYPE_INVALID,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
  g_assert (ret == 2);
  g_value_unset (&amp;val);
</programlisting>
	</para>
      </sect3>
      <sect3 id="glib-receiving-variant">
	<title>Receiving a variant</title>
	<para>
<programlisting>
  GValue val = {0, };

  error = NULL;
  if (!dbus_g_proxy_call (proxy, "GetVariant", &amp;error, G_TYPE_INVALID,
                          G_TYPE_VALUE, &amp;val, G_TYPE_INVALID))
    {
      /* Handle error */
    }
  if (G_VALUE_TYPE (&amp;val) == G_TYPE_STRING)
    printf ("%s\n", g_value_get_string (&amp;val));
  else if (G_VALUE_TYPE (&amp;val) == G_TYPE_INT)
    printf ("%d\n", g_value_get_int (&amp;val));
  else
    ...
  g_value_unset (&amp;val);
</programlisting>
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="glib-server">
    <title>GLib API: Implementing Objects</title>
    <para>
      At the moment, to expose a GObject via D-BUS, you must
      write XML by hand which describes the methods exported
      by the object.  In the future, this manual step will
      be obviated by the upcoming GLib introspection support.
    </para>
    <para>
      Here is a sample XML file which describes an object that exposes
      one method, named <literal>ManyArgs</literal>.
<programlisting>
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;

&lt;node name="/com/example/MyObject"&gt;

  &lt;interface name="com.example.MyObject"&gt;
    &lt;annotation name="org.freedesktop.DBus.GLib.CSymbol" value="my_object"/&gt;
    &lt;method name="ManyArgs"&gt;
      &lt;!-- This is optional, and in this case is redunundant --&gt;
      &lt;annotation name="org.freedesktop.DBus.GLib.CSymbol" value="my_object_many_args"/&gt;
      &lt;arg type="u" name="x" direction="in" /&gt;
      &lt;arg type="s" name="str" direction="in" /&gt;
      &lt;arg type="d" name="trouble" direction="in" /&gt;
      &lt;arg type="d" name="d_ret" direction="out" /&gt;
      &lt;arg type="s" name="str_ret" direction="out" /&gt;
    &lt;/method&gt;
  &lt;/interface&gt;
&lt;/node&gt;
</programlisting>
    </para>
    <para>
      This XML is in the same format as the D-BUS introspection XML
      format. Except we must include an "annotation" which give the C
      symbols corresponding to the object implementation prefix
      (<literal>my_object</literal>).  In addition, if particular
      methods symbol names deviate from C convention
      (i.e. <literal>ManyArgs</literal> -&gt;
      <literal>many_args</literal>), you may specify an annotation
      giving the C symbol.
    </para>
    <para>
      Once you have written this XML, run <literal>dbus-binding-tool --mode=glib-server <replaceable>FILENAME</replaceable> &gt; <replaceable>HEADER_NAME</replaceable>.</literal> to
      generate a header file.  For example: <command>dbus-binding-tool --mode=glib-server my-objet.xml &gt; my-object-glue.h</command>.
    </para>
    <para>
      Next, include the generated header in your program, and invoke
      <literal>dbus_g_object_class_install_info</literal>, passing the
      object class and "object info" included in the header.  For
      example:
      <programlisting>
	dbus_g_object_type_install_info (COM_FOO_TYPE_MY_OBJECT, &amp;com_foo_my_object_info);
      </programlisting>
      This should be done exactly once per object class.
    </para>
    <para>
      To actually implement the method, just define a C function named e.g.
      <literal>my_object_many_args</literal> in the same file as the info
      header is included.  At the moment, it is required that this function
      conform to the following rules:
      <itemizedlist>
	<listitem>
	  <para>
	    The function must return a value of type <literal>gboolean</literal>;
	    <literal>TRUE</literal> on success, and <literal>FALSE</literal>
	    otherwise.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    The first parameter is a pointer to an instance of the object.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Following the object instance pointer are the method
	    input values.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Following the input values are pointers to return values.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    The final parameter must be a <literal>GError **</literal>.
	    If the function returns <literal>FALSE</literal> for an
	    error, the error parameter must be initalized with
	    <literal>g_set_error</literal>.
	  </para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      Finally, you can export an object using <literal>dbus_g_connection_register_g_object</literal>.  For example:
      <programlisting>
	  dbus_g_connection_register_g_object (connection,
                                               "/com/foo/MyObject",
                                               obj);
      </programlisting>
    </para>
  </sect1>

  <sect1 id="qt-client">
    <title>Qt API: Using Remote Objects</title>
    <para>
      
      The Qt bindings are not yet documented.

    </para>
  </sect1>

  <sect1 id="qt-server">
    <title>Qt API: Implementing Objects</title>
    <para>
      The Qt bindings are not yet documented.
    </para>
  </sect1>


  <sect1 id="python-client">
    <title>Python API: Using Remote Objects</title>
    <para>
      The Python bindings are not yet documented, but the 
      bindings themselves are in good shape.
    </para>
  </sect1>

  <sect1 id="python-server">
    <title>Python API: Implementing Objects</title>
    <para>
      The Python bindings are not yet documented, but the 
      bindings themselves are in good shape.
    </para>
  </sect1>

</article>
