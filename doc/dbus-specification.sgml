<!doctype article PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [
]>
<article id="index">
  <artheader>
    <title>D-BUS Protocol Specification</title>
    <releaseinfo>Version 0.1</releaseinfo>
    <date>22 January 2003</date>
    <authorgroup>
      <author>
	<firstname>Havoc</firstname>
	<surname>Pennington</surname>
	<affiliation>
	  <address>
	    <email>hp@pobox.com</email>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
  </artheader>

  <sect1 id="introduction">
    <title>Introduction</title>
    <para>
      D-BUS is a system for low-latency, low-overhead, easy to use
      interprocess communication (IPC). In more detail:
      <itemizedlist>
        <listitem>
          <para>
            D-BUS is <emphasis>low-latency</emphasis> because it is designed 
            to avoid round trips and allow asynchronous operation, much like 
            the X protocol.
          </para>
        </listitem>
        <listitem>
          <para>
            D-BUS is <emphasis>low-overhead</emphasis> because it is uses a
            binary protocol, and does not have to convert to and from a text
            format such as XML. Because D-BUS is intended for potentially
            high-resolution same-machine IPC, not primarily for Internet IPC,
            this is an interesting optimization.
          </para>
        </listitem>
        <listitem>
          <para>
            D-BUS is <emphasis>easy to use</emphasis> because it works in terms
            of <firstterm>messages</firstterm> rather than byte streams, and
            does not require users to understand any complex concepts such as a
            new type system or elaborate APIs. Libraries implementing D-BUS 
            may choose to abstract messages as "method calls" (see 
            <xref linkend="message-conventions-method">).
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      The base D-BUS protocol is a peer-to-peer protocol, specified in <xref
      linkend="message-protocol">. That is, it is a system for one application
      to talk to a single other application. However, the primary intended
      application of D-BUS is the D-BUS <firstterm>message bus</firstterm>,
      specified in <xref linkend="message-bus">. The message bus is a special
      application that accepts connections from multiple other applications, and
      forwards messages among them.
    </para>
  </sect1>

  <sect1 id="message-protocol">
    <title>Message Protocol</title>
    <para>
      A <firstterm>message</firstterm> consists of a
      <firstterm>header</firstterm> and a <firstterm>body</firstterm>. If you
      think of a message as a package, the header is the address, and the body
      contains the package contents. The message delivery system uses the header
      information to figure out where to send the message and how to interpret
      it; the recipient inteprets the body of the message.
    </para>
    
    <para>
      The body of the message is made up of zero or more
      <firstterm>arguments</firstterm>, which are typed 
      values, such as an integer or a byte array.
    </para>

    <sect2 id="message-protocol-header-encoding">
      <title>Header Encoding</title>
      <para>
        Following the mandatory fields, there are zero or more named fields (see
        <xref linkend="message-protocol-header-fields">), and then nul bytes
        padding the header such that its total length in bytes is a multiple of
        8.
      </para>
      <para>
        The header MUST begin with the following mandatory fields in the following
        order:
        <informaltable>
          <tgroup cols=2>
            <thead>
              <row>
                <entry>Size</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1 byte</entry>
                <entry>Endianness flag; ASCII 'l' for little-endian 
                  or ASCII 'B' for big-endian.</entry>
              </row>
              <row>
                <entry>1 byte</entry>
                <entry>Bitwise OR of flags. Unknown flags
                  MUST be ignored. Currently-defined flags are described below.
                </entry>
              </row>
              <row>
                <entry>1 byte</entry>
                <entry>Major protocol version of the sending application.  If
                the major protocol version of the receiving application does not
                match, the applications will not be able to communicate and the
                D-BUS connection MUST be disconnected. The major protocol
                version for this version of the specification is 0.
                </entry>
              </row>
              <row>
                <entry>1 byte</entry>
                <entry>A nul byte, reserved for future use.
                  Any value for this byte MUST be accepted.
                </entry>
              </row>
              <row>
                <entry>4 bytes</entry>
                <entry>An unsigned 32-bit integer in the
                  message's byte order, indicating the total length in bytes of
                  the header including named fields and any alignment padding.
                  MUST be a multiple of 8.
                </entry>
              </row>
              <row>
                <entry>4 bytes</entry>
                <entry>An unsigned 32-bit integer in the
                  message's byte order, indicating the total length in bytes of
                  the message body.
                </entry>
              </row>      
              <row>
                <entry>4 bytes</entry>
                <entry>The message's serial number, a signed 32-bit integer in
                  the message's byte order. Applications MUST NOT reuse the same
                  serial number for different messages more often than 32-bit
                  integer wraparound. Serial numbers must be greater than 
                  zero.
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>
      <para>
        Flags that can appear in the second byte of the header:
        <informaltable id="message-protocol-header-flags">
          <tgroup cols=2>
            <thead>
              <row>
                <entry>Hex value</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0x1</entry>
                <entry>This message is an error reply.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>
    </sect2>

    <sect2 id="message-protocol-header-fields">
      <title>Header Fields</title>
      <para>
        In addition to the required header information mentioned 
        in <xref linkend="message-protocol-header-encoding">, 
          the header may contain zero or more named 
          header fields. These fields are named to allow 
          future versions of this protocol specification to 
          add new fields; implementations must ignore fields 
          they do not understand. Implementations must not 
          invent their own header fields; only changes to 
          this specification may introduce new header fields.
      </para>
      
    </sect2>
    <sect2 id="message-protocol-header-padding">
      <title>Header Alignment Padding</title>
      <para>
        To allow implementations to keep the header and the body in a single
        buffer while keeping data types aligned, the total length of the header
        must be a multiple of 8 bytes.  To achieve this, the header MUST be padded
        with nul bytes to align its total length on an 8-byte boundary. 
        The minimum number of padding bytes MUST be used. Because all possible 
        named fields use at least 8 bytes, implementations can distinguish 
        padding (which must be less than 8 bytes) from additional named fields
        (which must be at least 8 bytes).
      </para>
    </sect2>

    <sect2 id="message-protocol-arguments">
      <title>Message Arguments</title>
      <para>
        The message body is made up of arguments. Each argument
        is a type code, followed by the value of the argument 
        in a type-dependent format.
      </para>
      <para>
        The type codes are as follows:
        <informaltable>
          <tgroup cols=3>
            <thead>
              <row>
                <entry>Type name</entry>
                <entry>Code</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>INVALID</entry>
                <entry>0</entry>
                <entry>Not a valid type code (error if it appears in a message)</entry>
              </row><row>
                <entry>NIL</entry>
                <entry>1</entry>
                <entry>Marks an "unset" or "nonexistent" argument</entry>
              </row><row>
                <entry>INT32</entry>
                <entry>2</entry>
                <entry>32-bit signed integer</entry>
              </row><row>
                <entry>UINT32</entry>
                <entry>3</entry>
                <entry>32-bit unsigned integer</entry>
              </row><row>
                <entry>DOUBLE</entry>
                <entry>4</entry>
                <entry>IEEE 754 double</entry>
              </row><row>
                <entry>STRING</entry>
                <entry>5</entry>
                <entry>UTF-8 string (<emphasis>must</emphasis> be valid UTF-8)</entry>
              </row><row>
                <entry>INT32_ARRAY</entry>
                <entry>6</entry>
                <entry>Array of INT32</entry>
              </row><row>
                <entry>UINT32_ARRAY</entry>
                <entry>7</entry>
                <entry>Array of UINT32</entry>
              </row><row>
                <entry>DOUBLE_ARRAY</entry>
                <entry>8</entry>
                <entry>Array of DOUBLE</entry>
              </row><row>
                <entry>BYTE_ARRAY</entry>
                <entry>9</entry>
                <entry>Array of bytes</entry>
              </row><row>
                <entry>STRING_ARRAY</entry>
                <entry>10</entry>
                <entry>Array of STRING</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>
      <para>
        The types are encoded as follows:
      </para>
    </sect2>
  </sect1>

  <sect1 id="auth-protocol">
    <title>Authentication Protocol</title>
    <para>
      Before the flow of messages begins, two applications 
      must authenticate. A simple text protocol is used 
      for authentication; this protocol is a SASL profile, 
      and maps fairly directly from the SASL specification.
    </para>
    <para>
      [move the dbus-sasl-profile.txt stuff into here and clean it up]
    </para>
  </sect1>

  <sect1 id="addresses">
    <title>Server Addresses</title>
    <para>
      [document the string format of an address, and how it maps 
      to unix domain sockets, tcp, or whatever]
    </para>
  </sect1>

  <sect1 id="message-conventions">
    <title>Message Conventions</title>
    <para>
      This section documents conventions that are not essential to D-BUS
      functionality, but should generally be followed in order to simplify
      programmer's lives.
    </para>
    <sect2 id="message-conventions-naming">
      <title>Message Naming</title>
      <para>
        Messages are normally named in the form 
        "org.freedesktop.Peer.Ping", which has three 
        distinct components:
        <variablelist>
          <varlistentry>
            <term>Namespace e.g. <literal>org.freedesktop</literal></term>
            <listitem>
              <para>
                Message names have a Java-style namespace: a reversed domain
                name. The components of the domain are normally lowercase.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Package or object e.g. <literal>Peer</literal></term>
            <listitem>
              <para>
                The next part of the message name can be thought of as the name
                of a singleton object, or as the name of a package of related
                messages.  More than one dot-separated component might be used
                here. (Note that D-BUS does not define any idea of object
                instances or object references.)  The package or object name is
                capitalized LikeThis.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Method or operation e.g. <literal>Ping</literal></term>
            <listitem>
              <para>
                The final part of the message name is the most specific, and
                should be a verb indicating an operation to be performed on the
                object.  The method or operation name is capitalized LikeThis.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
      <para>
        A reply to a message is conventionally named by 
        appending the string <literal>:Reply</literal>. 
        So the reply to <literal>org.freedesktop.Peer.Ping</literal>
        is <literal>org.freedesktop.Peer.Ping:Reply</literal>.
      </para>
    </sect2>
    <sect2 id="message-conventions-method">
      <title>Method Call Mapping</title>
      <para>
        Some implementations of D-BUS may present an API that translates object
        method calls into D-BUS messages. This document does not specify in
        detail how such an API should look or work. However, it does specify how
        message-based protocols should be designed to be friendly to such an
        API.
      </para>
      <para>
        Remember that D-BUS does not have object references or object instances.
        So when one application sends the message
        <literal>org.freedesktop.Peer.Ping</literal>, it sends it to another
        application, not to any kind of sub-portion of that application.
        However, a convenience API used within the recipient application may
        route all messages that start with
        <literal>org.freedesktop.Peer</literal> to a particular object instance,
        and may invoke the <literal>Ping()</literal> method on said instance in
        order to handle the message. This is a convenience API based on 
        method calls.
      </para>
      <para>
        A "method call" consists of a message and, optionally, a reply to that
        message. The name of the "method" is the last component of the message,
        for example, <literal>org.freedesktop.Peer.Ping</literal> would map to
        the method <literal>Ping()</literal> on some object.
      </para>
      <para>
        Arguments to a method may be considered "in" (processed by the
        recipient of the message), or "out" (returned to the sender of the
        message in the reply). "inout" arguments are both sent and received,
        i.e. the caller passes in a value which is modified.
      </para>
      <para>
        Given a method with zero or one return values, followed by zero or more
        arguments, where each argument may be "in", "out", or "inout", the
        caller constructs a message by appending each "in" or "inout" argument,
        in order. "out" arguments are not represented in the caller's message.
      </para>
      <para>
        The recipient constructs a reply by appending first the return value 
        if any, then each "out" or "inout" argument, in order. 
        "in" arguments are not represented in the reply message.
      </para>
    </sect2>
  </sect1>

  <sect1 id="standard-messages">
    <title>Standard Peer-to-Peer Messages</title>
    <para>
      In the following message definitions, "method call notation" is presented
      in addition to simply listing the message names and arguments. The special
      type name ANY means any type other than NIL, and the special type name
      ANY_OR_NIL means any valid type.
      [FIXME the messages here are just made up to illustrate the 
      format for defining them]
    </para>
    <sect2 id="standard-messages-ping">
      <title><literal>org.freedesktop.Peer.Ping</literal></title>
      <para>        
        As a method:
        <programlisting>
          void Ping ()
        </programlisting>
      </para>
      <para>
        On receipt of the message <literal>org.freedesktop.Peer.Ping</literal>,
        an application should reply with
        <literal>org.freedesktop.Peer.Ping:Reply</literal>. Neither the 
        message nor its reply have any arguments.
      [FIXME the messages here are just made up to illustrate the 
      format for defining them]
      </para>
    </sect2>
    <sect2 id="standard-messages-get-props">
      <title><literal>org.freedesktop.Props.Get</literal></title>
      <para>
        As a method:
        <programlisting>
          ANY_OR_NIL Get (in STRING property_name)
        </programlisting>
        Message arguments:
        <informaltable>
          <tgroup cols=3>
            <thead>
              <row>
                <entry>Argument</entry>
                <entry>Type</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>STRING</entry>
                <entry>Name of the property to get</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        Reply arguments:
        <informaltable>
          <tgroup cols=3>
            <thead>
              <row>
                <entry>Argument</entry>
                <entry>Type</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>ANY_OR_NIL</entry>
                <entry>The value of the property. The type depends on the property.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>
      <para>
        
      [FIXME the messages here are just made up to illustrate the 
      format for defining them]
      </para>
    </sect2>
  </sect1>

  <sect1 id="message-bus">
    <title>Message Bus Specification</title>
    <sect2 id="message-bus-overview">
      <title>Message Bus Overview</title>
      <para>
        The message bus accepts connections from one or more applications. 
        Once connected, applications can send and receive messages from 
        the message bus, as in the peer-to-peer case.
      </para>
      <para>
        The message bus keeps track of a set of
        <firstterm>services</firstterm>. A service is simply a name, such 
        as <literal>com.yoyodyne.Screensaver</literal>, which can be 
        <firstterm>owned</firstterm> by one of the connected applications. 
        The message bus itself always owns the special service 
        <literal>org.freedesktop.DBus</literal>.
      </para>
      <para>
        Messages may have a <literal>srvc</literal> field (see <xref
        linkend="message-protocol-header-fields">).  When the message bus
        receives a message, if the <literal>srvc</literal> field is absent, the
        message is taken to be a standard peer-to-peer message and interpreted
        by the message bus itself. For example, sending
          an <literal>org.freedesktop.Peer.Ping</literal> message with no 
          <literal>srvc</literal> will cause the message bus itself to reply 
          to the ping immediately; the message bus would never make 
          this message visible to other applications.
      </para>
      <para>
        If the <literal>srvc</literal> field is present, then it indicates a
        request for the message bus to route the message. In the usual case,
        messages are routed to the owner of the named service.
        Messages may also be <firstterm>broadcast</firstterm>
        by sending them to the special service 
        <literal>org.freedesktop.Broadcast</literal>. Broadcast messages 
        are sent to all applications with <firstterm>message matching rules</firstterm>
        that match the message.
      </para>
      <para>
        Continuing the <literal>org.freedesktop.Peer.Ping</literal> example, if
        the ping message were sent with a <literal>srvc</literal> name of
        <literal>com.yoyodyne.Screensaver</literal>, then the ping would be
        forwarded, and the Yoyodyne Corporation screensaver application would be
        expected to reply to the ping. If
        <literal>org.freedesktop.Peer.Ping</literal> were sent to
        <literal>org.freedesktop.Broadcast</literal>, then multiple applications
        might receive the ping, and all would normally reply to it.
      </para>
    </sect2>
    <sect2 id="message-bus-messages">
      <title>Message Bus Messages</title>
      <para>
        The special message bus service <literal>org.freedesktop.DBus</literal>
        responds to a number of messages, allowing applications to 
        interact with the message bus.
      </para>
      <para>
        [document the messages here]
      </para>
    </sect2>
    <sect2 id="message-bus-activation">
      <title>Message Bus Service Activation</title>
      <para>
        [document file format, filesystem locations, etc. for activation]
      </para>
    </sect2>
    <sect2 id="message-bus-location">
      <title>Finding The Message Bus</title>
      <para>
        Two standard message bus instances are defined here, along with how 
        to locate them.
      </para>
      <para>
        Each time a user logs in, a <firstterm>desktop session message
        bus</firstterm> may be started. All applications in the user's login
        session may interact with one another using this message bus.  [specify
        how to find the address of the desktop session message bus via
        environment variable and/or X property]
      </para>
      <para>
        A computer may have a <firstterm>system message bus</firstterm>,
        accessible to all applications on the system. This message bus may be
        used to broadcast system events, such as adding new hardware devices.
        [specify how to find the address of the system message bus]
      </para>
    </sect2>
  </sect1>

  <appendix id="implementation-notes">
    <title>Implementation notes</title>
    <sect1 id="implementation-notes-subsection">
      <title></title>
      <para>

      </para>
    </sect1>
  </appendix>
  <glossary><title>Glossary</title>
    <para>
      This glossary defines some of the terms used in this specification.
    </para>

    <glossentry id="term-broadcast"><glossterm>Broadcast</glossterm>
      <glossdef>
        <para>
          A message sent to the special <literal>org.freedesktop.Broadcast</literal>
          service; the message bus will forward the broadcast message 
          to all clients that have expressed interest in it.
        </para>
      </glossdef>
    </glossentry>
      
    <glossentry id="term-message"><glossterm>Message</glossterm>
      <glossdef>
        <para>
          A message is the atomic unit of communication via the D-BUS
          protocol. It consists of a <firstterm>header</firstterm> and a
          <firstterm>body</firstterm>; the body is made up of
          <firstterm>arguments</firstterm>.
        </para>
      </glossdef>
    </glossentry>

    <glossentry id="term-message-bus"><glossterm>Message Bus</glossterm>
      <glossdef>
        <para>
          The message bus is a special application that forwards 
          or broadcasts messages between a group of applications
          connected to the message bus. It also manages 
          <firstterm>services</firstterm>.
        </para>
      </glossdef>
    </glossentry>

    <glossentry id="term-service"><glossterm>Service</glossterm>
      <glossdef>
        <para>
          A service is simply a named application that other 
          applications can refer to. For example, the 
          hypothetical <literal>com.yoyodyne.Screensaver</literal>
          service might accept messages that affect 
          a screensaver from Yoyodyne Corporation.
          An application is said to <firstterm>own</firstterm> 
          a service if the message bus has associated the 
          application with the service name.
        </para>
      </glossdef>
    </glossentry>

  </glossary>
</article>

